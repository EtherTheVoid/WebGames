<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cyber Snake: Grid Runner</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&display=swap" rel="stylesheet">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.7.77/Tone.js"></script>
    <style>
        :root {
            --primary-color: #00ffff;
            --secondary-color: #ff00ff;
            --danger-color: #ff3333;
            --background-color: #0a0a1a;
            --grid-color: rgba(0, 255, 255, 0.1);
            --text-color: #f0f0f0;
            --font-family: 'Share Tech Mono', monospace;
        }

        * {
            box-sizing: border-box;
        }

        body {
            background-color: var(--background-color);
            color: var(--text-color);
            font-family: var(--font-family);
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
            text-shadow: 0 0 5px var(--primary-color);
        }

        .game-container {
            width: 95vw;
            max-width: 800px;
            max-height: 95vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 20px var(--primary-color);
            background: rgba(10, 10, 26, 0.8);
            padding: 20px;
            border-radius: 15px;
        }

        .hud {
            width: 100%;
            display: flex;
            justify-content: space-between;
            margin-bottom: 15px;
            font-size: 1.2em;
            padding: 0 10px;
        }
        
        #creds-display::before { content: 'Creds: '; }
        #score-display::before { content: 'Score: '; }

        canvas {
            background-color: var(--background-color);
            background-image:
                linear-gradient(var(--grid-color) 1px, transparent 1px),
                linear-gradient(90deg, var(--grid-color) 1px, transparent 1px);
            background-size: 20px 20px;
            border: 1px solid var(--secondary-color);
            box-shadow: inset 0 0 15px var(--secondary-color);
            width: 100%;
            max-height: 65vh;
            aspect-ratio: 1 / 1;
            border-radius: 8px;
        }
        
        /* --- MODALS --- */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
            backdrop-filter: blur(5px);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }
        
        .modal-overlay.visible {
            opacity: 1;
            visibility: visible;
        }

        .modal-content {
            background: var(--background-color);
            padding: 30px;
            border-radius: 10px;
            border: 2px solid var(--primary-color);
            box-shadow: 0 0 25px var(--primary-color);
            text-align: center;
            max-width: 90%;
            width: 500px;
        }

        .modal-content h2 {
            color: var(--primary-color);
            margin-top: 0;
            font-size: 2em;
        }
        .modal-content p {
            margin-bottom: 25px;
            line-height: 1.6;
        }
        
        .modal-button, .market-button {
            background: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
            padding: 10px 20px;
            margin: 5px;
            cursor: pointer;
            font-family: var(--font-family);
            font-size: 1em;
            transition: all 0.3s ease;
            box-shadow: 0 0 5px var(--primary-color);
            border-radius: 5px;
        }

        .modal-button:hover, .market-button:hover {
            background: var(--primary-color);
            color: var(--background-color);
            box-shadow: 0 0 15px var(--primary-color);
            text-shadow: none;
        }
        
        .modal-button.tier-2, .modal-button.tier-3 {
             border-color: var(--secondary-color);
             color: var(--secondary-color);
             box-shadow: 0 0 5px var(--secondary-color);
        }
         .modal-button.tier-2:hover, .modal-button.tier-3:hover {
             background: var(--secondary-color);
             color: var(--background-color);
             box-shadow: 0 0 15px var(--secondary-color);
        }
        
        .modal-button.danger {
            border-color: var(--danger-color);
            color: var(--danger-color);
            box-shadow: 0 0 5px var(--danger-color);
        }
        .modal-button.danger:hover {
            background: var(--danger-color);
            color: var(--background-color);
            box-shadow: 0 0 15px var(--danger-color);
        }

        .modal-button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            border-color: #555;
            color: #555;
            box-shadow: none;
            background: transparent;
            text-shadow: none;
        }

        .market-container {
            margin-top: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
        }
        
        #market-cosmetics {
            margin-top: 20px;
            max-height: 150px;
            overflow-y: auto;
            border: 1px solid var(--grid-color);
            padding: 10px;
            border-radius: 5px;
        }

        #market-cosmetics div {
            padding: 5px;
            cursor: pointer;
            border-radius: 4px;
        }
        
        #market-cosmetics div.selected {
            background-color: var(--primary-color);
            color: var(--background-color);
            text-shadow: none;
        }

        .modal-button-group {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            width: 100%;
        }

        .modal-button-group .modal-button {
            width: 80%;
            max-width: 350px;
        }

    </style>
</head>
<body>
    <div class="game-container">
        <div class="hud">
            <span id="creds-display">1000</span>
            <span id="score-display">0</span>
        </div>
        <canvas id="game-canvas"></canvas>
        <div class="market-container">
            <button class="market-button" id="open-market-btn">// BLACK MARKET //</button>
        </div>
    </div>
    
    <!-- Heist Wager Modal -->
    <div id="wager-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>// INITIATE HEIST //</h2>
            <p>Select your risk level. Higher wagers yield greater rewards but increase system hostility.</p>
            <button class="modal-button" id="tier-1-btn">Tier 1: Standard Run (Free)</button>
            <button class="modal-button tier-2" id="tier-2-btn">Tier 2: Encrypted Sector (100 Creds)</button>
            <button class="modal-button tier-3" id="tier-3-btn">Tier 3: Core Mainframe (500 Creds)</button>
        </div>
    </div>
    
    <!-- Game Over Modal -->
    <div id="game-over-modal" class="modal-overlay">
        <div class="modal-content">
            <h2 id="game-over-title">// SYSTEM CORRUPTION //</h2>
            <p id="game-over-message">Your data worm has been purged. Run terminated.</p>
            <p>Final Score: <span id="final-score">0</span></p>
            <p>Creds Earned: <span id="creds-earned">0</span></p>
            <p>Wager Cost: <span id="wager-cost">0</span></p>
            <p>Net Creds: <span id="net-creds">0</span></p>
            <div class="modal-button-group">
                <button class="modal-button" id="play-again-btn">New Heist</button>
                <button class="modal-button danger" id="reboot-btn">System Reboot (Watch Ad)</button>
            </div>
        </div>
    </div>

    <!-- Overclock Modal -->
    <div id="overclock-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>// GLITCH FRAGMENT DETECTED //</h2>
            <p>Initiate Overclock Protocol? High risk. System instability imminent. Crashing during Overclock results in total loss of run assets and wager.</p>
            <button class="modal-button danger" id="accept-overclock-btn">ACCEPT [MAXIMUM RISK]</button>
            <button class="modal-button" id="decline-overclock-btn">DECLINE</button>
        </div>
    </div>

    <!-- Black Market Modal -->
    <div id="market-modal" class="modal-overlay">
        <div class="modal-content">
            <h2>// BLACK MARKET //</h2>
            <p>Spend your Creds on Encrypted Drives for a chance at rare cosmetics.</p>
            <button class="modal-button" id="buy-drive-btn">Purchase Encrypted Drive (250 Creds)</button>
            <button class="modal-button" id="watch-ad-drive-btn">Open Free Drive (Watch Ad)</button>
            <div id="market-cosmetics">
                <h3>// LOADOUT //</h3>
                <!-- Unlocked cosmetics will be listed here -->
            </div>
            <button class="modal-button" id="close-market-btn">Exit Market</button>
        </div>
    </div>


    <script>
        // --- DOM ELEMENTS ---
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const credsDisplay = document.getElementById('creds-display');
        const scoreDisplay = document.getElementById('score-display');
        const wagerModal = document.getElementById('wager-modal');
        const gameOverModal = document.getElementById('game-over-modal');
        const overclockModal = document.getElementById('overclock-modal');
        const marketModal = document.getElementById('market-modal');

        // --- GAME CONSTANTS & VARIABLES ---
        const GRID_SIZE = 20;
        let TILE_COUNT;
        let creds = 1000;
        let score = 0;
        let currentRunCreds = 0;
        let gameSpeed = 100;
        let gameLoopInterval;
        let gameState = 'menu'; // 'menu', 'playing', 'paused', 'gameOver'
        let currentWager = 0;
        
        // --- WORM STATE ---
        let worm = [{ x: 10, y: 10 }];
        let dx = 0;
        let dy = 0;
        let changingDirection = false;

        // --- FRAGMENT STATE ---
        let fragment = { x: 15, y: 15 };
        let fragmentValue = 10;
        let fragmentCredValue = 1;
        let glitchFragment = null;
        
        // --- TIER 3 OBSTACLES ---
        let obstacles = [];

        // --- OVERCLOCK STATE ---
        let overclockActive = false;
        let overclockTimer;
        
        // --- COSMETICS ---
        const allCosmetics = [
            { id: 'default', name: 'Default Neon', type: 'color', value: '#00ffff' },
            { id: 'magenta', name: 'Magenta Shock', type: 'color', value: '#ff00ff' },
            { id: 'lime', name: 'Virus Green', type: 'color', value: '#39FF14' },
            { id: 'orange', name: 'Molten Core', type: 'color', value: '#FFA500' },
        ];
        let unlockedCosmetics = ['default'];
        let activeCosmetic = allCosmetics[0];

        // --- SOUND SYNTHESIS (Tone.js) ---
        const synth = new Tone.Synth().toDestination();
        const crashSynth = new Tone.NoiseSynth({ noise: { type: 'white' }, envelope: { attack: 0.005, decay: 0.1, sustain: 0 } }).toDestination();
        const music = new Tone.Loop(time => {
            synth.triggerAttackRelease("C2", "8n", time);
        }, "4n");

        // --- UTILITY FUNCTIONS ---
        function updateUI() {
            credsDisplay.textContent = creds;
            scoreDisplay.textContent = score;
        }

        function showModal(modal) {
            modal.classList.add('visible');
        }

        function hideModal(modal) {
            modal.classList.remove('visible');
        }

        function getRandomPosition() {
            return {
                x: Math.floor(Math.random() * TILE_COUNT),
                y: Math.floor(Math.random() * TILE_COUNT)
            };
        }

        // --- GAME SETUP & RESET ---
        function resetGame() {
            worm = [{ x: 10, y: 10 }];
            dx = 0;
            dy = 0;
            score = 0;
            currentRunCreds = 0;
            overclockActive = false;
            clearTimeout(overclockTimer);
            glitchFragment = null;
            obstacles = [];
            currentWager = 0;
            updateUI();
        }

        function startGame(tier) {
            resetGame();
            
            let wager = 0;
            let speedMultiplier = 1;
            fragmentValue = 10;
            fragmentCredValue = 1;
            
            switch (tier) {
                case 2:
                    wager = 100;
                    speedMultiplier = 1.3;
                    fragmentCredValue = 5;
                    break;
                case 3:
                    wager = 500;
                    speedMultiplier = 1.6;
                    fragmentCredValue = 10;
                    spawnObstacles(3);
                    break;
            }
            
            currentWager = wager;

            if (creds < wager) {
                alert("Not enough Creds for this heist!");
                return;
            }

            // creds -= wager; // Wager is no longer deducted at the start
            updateUI();
            
            gameSpeed = 120 / speedMultiplier;
            music.playbackRate = speedMultiplier;

            hideModal(wagerModal);
            gameState = 'playing';
            
            if (Tone.context.state !== 'running') {
                Tone.start();
            }
            Tone.Transport.start();
            music.start(0);

            gameLoopInterval = setInterval(gameLoop, gameSpeed);
        }

        function spawnFragment() {
            fragment = getRandomPosition();
            // Ensure fragment doesn't spawn on worm
            for (const segment of worm) {
                if (segment.x === fragment.x && segment.y === segment.y) {
                    spawnFragment();
                    return;
                }
            }
            // 10% chance to spawn a glitch fragment
            if (Math.random() < 0.1 && !glitchFragment) {
                glitchFragment = getRandomPosition();
            }
        }

        function spawnObstacles(count) {
            obstacles = [];
            for (let i = 0; i < count; i++) {
                obstacles.push({ ...getRandomPosition(), dx: Math.random() > 0.5 ? 1 : -1, dy: 0 });
            }
        }

        // --- DRAWING FUNCTIONS ---
        function draw() {
            // Clear canvas
            ctx.fillStyle = 'rgba(10, 10, 26, 0.8)'; // Fading trail effect
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw worm
            worm.forEach((segment, index) => {
                ctx.fillStyle = activeCosmetic.value;
                if (index === 0) { // Head
                    ctx.fillStyle = lightenColor(activeCosmetic.value, 30);
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = activeCosmetic.value;
                } else {
                    ctx.shadowBlur = 10;
                    ctx.shadowColor = activeCosmetic.value;
                }
                ctx.fillRect(segment.x * GRID_SIZE, segment.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                ctx.shadowBlur = 0; // Reset shadow
            });

            // Draw fragment
            ctx.fillStyle = '#f0f0f0';
            ctx.strokeStyle = '#f0f0f0';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#f0f0f0';
            ctx.fillRect(fragment.x * GRID_SIZE + GRID_SIZE/4, fragment.y * GRID_SIZE + GRID_SIZE/4, GRID_SIZE/2, GRID_SIZE/2);
            ctx.shadowBlur = 0;

            // Draw glitch fragment
            if (glitchFragment) {
                ctx.fillStyle = `hsl(${Date.now() / 10 % 360}, 100%, 70%)`;
                ctx.shadowColor = ctx.fillStyle;
                ctx.shadowBlur = 20;
                ctx.fillRect(glitchFragment.x * GRID_SIZE, glitchFragment.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                ctx.shadowBlur = 0;
            }
            
            // Draw obstacles
            obstacles.forEach(ob => {
                ctx.fillStyle = '#ff3333';
                ctx.shadowBlur = 10;
                ctx.shadowColor = '#ff3333';
                ctx.fillRect(ob.x * GRID_SIZE, ob.y * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                ctx.shadowBlur = 0;
            });
        }
        
        function lightenColor(hex, percent) {
            let r = parseInt(hex.slice(1, 3), 16);
            let g = parseInt(hex.slice(3, 5), 16);
            let b = parseInt(hex.slice(5, 7), 16);
            r = Math.min(255, r + (255 * percent / 100));
            g = Math.min(255, g + (255 * percent / 100));
            b = Math.min(255, b + (255 * percent / 100));
            return `rgb(${Math.round(r)},${Math.round(g)},${Math.round(b)})`;
        }

        // --- GAME LOGIC & LOOP ---
        function moveWorm() {
            const head = { x: worm[0].x + dx, y: worm[0].y + dy };
            worm.unshift(head);
            worm.pop();
        }
        
        function moveObstacles() {
            obstacles.forEach(ob => {
                ob.x += ob.dx;
                if (ob.x < 0) ob.x = TILE_COUNT - 1;
                if (ob.x >= TILE_COUNT) ob.x = 0;
            });
        }

        function checkCollisions() {
            const head = worm[0];

            // Wall collision
            if (head.x < 0 || head.x >= TILE_COUNT || head.y < 0 || head.y >= TILE_COUNT) {
                return true;
            }

            // Self collision
            for (let i = 1; i < worm.length; i++) {
                if (head.x === worm[i].x && head.y === worm[i].y) {
                    return true;
                }
            }
            
            // Obstacle collision
            for (const ob of obstacles) {
                 if (head.x === ob.x && head.y === ob.y) {
                    return true;
                }
            }

            return false;
        }

        function handleFragmentConsumption() {
            const head = worm[0];

            if (head.x === fragment.x && head.y === fragment.y) {
                // Eat fragment
                score += overclockActive ? fragmentValue * 2 : fragmentValue;
                currentRunCreds += overclockActive ? fragmentCredValue * 2 : fragmentCredValue;
                worm.push({}); // Grow worm
                spawnFragment();
                synth.triggerAttackRelease("C5", "8n");
                updateUI();
            }
            
            if (glitchFragment && head.x === glitchFragment.x && head.y === glitchFragment.y) {
                glitchFragment = null;
                pauseForOverclock();
            }
        }
        
        function pauseForOverclock() {
            gameState = 'paused';
            clearInterval(gameLoopInterval);
            music.stop();
            showModal(overclockModal);
        }
        
        function resumeFromOverclock(accepted) {
            hideModal(overclockModal);
            if (accepted) {
                overclockActive = true;
                const overclockSpeed = gameSpeed / 2;
                gameLoopInterval = setInterval(gameLoop, overclockSpeed);
                music.playbackRate *= 2;
                music.start(0);

                overclockTimer = setTimeout(() => {
                    overclockActive = false;
                    clearInterval(gameLoopInterval);
                    gameLoopInterval = setInterval(gameLoop, gameSpeed);
                    music.playbackRate /= 2;
                }, 30000);
            } else {
                 gameLoopInterval = setInterval(gameLoop, gameSpeed);
                 music.start(0);
            }
             gameState = 'playing';
        }

        function gameOver() {
            gameState = 'gameOver';
            clearInterval(gameLoopInterval);
            music.stop();
            crashSynth.triggerAttackRelease("8n");

            const gameOverTitle = document.getElementById('game-over-title');
            const gameOverMsg = document.getElementById('game-over-message');
            const finalScore = document.getElementById('final-score');
            const credsEarnedDisplay = document.getElementById('creds-earned');
            const wagerCostDisplay = document.getElementById('wager-cost');
            const netCredsDisplay = document.getElementById('net-creds');
            const rebootBtn = document.getElementById('reboot-btn');
            rebootBtn.style.display = 'block'; // Show reboot by default

            let netResult = 0;

            if (overclockActive) {
                gameOverTitle.textContent = "// OVERCLOCK FAILURE //";
                gameOverMsg.textContent = "Catastrophic failure. Run assets and wager are lost.";
                currentRunCreds = 0;
                netResult = -currentWager;
                rebootBtn.style.display = 'none'; // Cannot reboot from overclock failure
            } else {
                gameOverTitle.textContent = "// SYSTEM CORRUPTION //";
                gameOverMsg.textContent = "Your data worm has been purged. Run terminated.";
                netResult = currentRunCreds - currentWager;
            }
            
            creds += netResult;

            finalScore.textContent = score;
            credsEarnedDisplay.textContent = currentRunCreds;
            wagerCostDisplay.textContent = currentWager;
            
            netCredsDisplay.textContent = netResult;
            netCredsDisplay.style.color = netResult >= 0 ? 'var(--primary-color)' : 'var(--danger-color)';
            
            updateUI();
            showModal(gameOverModal);
        }

        function gameLoop() {
            if (gameState !== 'playing') return;

            changingDirection = false;
            moveWorm();
            moveObstacles();

            if (checkCollisions()) {
                gameOver();
                return;
            }

            handleFragmentConsumption();
            draw();
        }

        // --- EVENT LISTENERS ---
        document.addEventListener('keydown', e => {
            if (changingDirection) return;
            changingDirection = true;
            
            const keyPressed = e.key;
            const goingUp = dy === -1;
            const goingDown = dy === 1;
            const goingRight = dx === 1;
            const goingLeft = dx === -1;

            if ((keyPressed === 'ArrowLeft' || keyPressed.toLowerCase() === 'a') && !goingRight) { dx = -1; dy = 0; }
            if ((keyPressed === 'ArrowUp' || keyPressed.toLowerCase() === 'w') && !goingDown) { dx = 0; dy = -1; }
            if ((keyPressed === 'ArrowRight' || keyPressed.toLowerCase() === 'd') && !goingLeft) { dx = 1; dy = 0; }
            if ((keyPressed === 'ArrowDown' || keyPressed.toLowerCase() === 's') && !goingUp) { dx = 0; dy = 1; }
        });
        
        // --- MODAL BUTTONS ---
        document.getElementById('tier-1-btn').addEventListener('click', () => startGame(1));
        document.getElementById('tier-2-btn').addEventListener('click', () => startGame(2));
        document.getElementById('tier-3-btn').addEventListener('click', () => startGame(3));
        
        document.getElementById('play-again-btn').addEventListener('click', () => {
            hideModal(gameOverModal);
            init();
        });

        document.getElementById('reboot-btn').addEventListener('click', () => {
            alert("Ad simulation: You've been granted one continue!");
            // This is a simulation. A real implementation would show an ad.
            hideModal(gameOverModal);
            // Simple "continue": just restart the level without penalty
            init();
        });
        
        document.getElementById('accept-overclock-btn').addEventListener('click', () => resumeFromOverclock(true));
        document.getElementById('decline-overclock-btn').addEventListener('click', () => resumeFromOverclock(false));
        
        document.getElementById('open-market-btn').addEventListener('click', () => showModal(marketModal));
        document.getElementById('close-market-btn').addEventListener('click', () => hideModal(marketModal));

        document.getElementById('buy-drive-btn').addEventListener('click', () => {
            if (creds >= 250) {
                creds -= 250;
                updateUI();
                openEncryptedDrive();
            } else {
                alert("Not enough Creds!");
            }
        });

        document.getElementById('watch-ad-drive-btn').addEventListener('click', () => {
            alert("Ad simulation: You received a free Encrypted Drive!");
            openEncryptedDrive();
        });

        // --- MARKET LOGIC ---
        function openEncryptedDrive() {
            // Simple gacha logic
            const availableCosmetics = allCosmetics.filter(c => !unlockedCosmetics.includes(c.id));
            if (availableCosmetics.length === 0) {
                alert("All cosmetics unlocked!");
                creds += 250; // Refund if all unlocked
                updateUI();
                return;
            }

            const wonCosmetic = availableCosmetics[Math.floor(Math.random() * availableCosmetics.length)];
            unlockedCosmetics.push(wonCosmetic.id);
            alert(`// DRIVE DECRYPTED //\n\nYou unlocked: ${wonCosmetic.name}!`);
            updateMarketUI();
        }
        
        function updateMarketUI() {
            const container = document.getElementById('market-cosmetics');
            container.innerHTML = '<h3>// LOADOUT //</h3>'; // Clear previous list
            allCosmetics.forEach(cosmetic => {
                if (unlockedCosmetics.includes(cosmetic.id)) {
                    const div = document.createElement('div');
                    div.textContent = cosmetic.name;
                    if (cosmetic.id === activeCosmetic.id) {
                        div.classList.add('selected');
                    }
                    div.style.color = cosmetic.value;
                    div.style.textShadow = `0 0 5px ${cosmetic.value}`;
                    div.addEventListener('click', () => {
                        activeCosmetic = cosmetic;
                        updateMarketUI();
                    });
                    container.appendChild(div);
                }
            });
        }

        // --- INITIALIZATION ---
        function init() {
            resetGame();
            draw();
            updateUI();
            updateMarketUI();
            const tier2Btn = document.getElementById('tier-2-btn');
            const tier3Btn = document.getElementById('tier-3-btn');
            tier2Btn.disabled = creds < 100;
            tier3Btn.disabled = creds < 500;
            showModal(wagerModal);
        }

        window.onload = () => {
            // Set canvas resolution to its displayed size to ensure 1:1 pixel ratio
            // and prevent stretching, making everything perfectly square.
            const size = canvas.clientWidth;
            canvas.width = size;
            canvas.height = size;
            TILE_COUNT = canvas.width / GRID_SIZE;

            init();
        };

    </script>
</body>
</html>

